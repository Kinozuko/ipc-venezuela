# -*- coding: utf-8 -*-
"""IPC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jzdlNlhWXPiVY0dQ6Vj7XqoaYhxswP7r

# Librerias
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x

import math
import tensorflow as tf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.metrics import confusion_matrix, f1_score
from sklearn.model_selection import train_test_split
from sklearn.utils import class_weight
import seaborn as sn

"""# IPC Dataset

Lectura del dataset
"""

df_ipc = pd.read_csv('data/ipc1719.csv')

"""Se obtienes una descripcion general de los datos"""

df_ipc.describe(include='all')

"""Se observan los primeros 5 valores de los datos para obtener una vista preliminar"""

df_ipc.head()

"""Se observa la densidad del valor del IPC desde el periodo del 2017 hasta enero del 2020"""

df_ipc.valor.plot.density()

"""Se convierte la columna fecha como indice del dataframe"""

df_ipc.index = pd.DatetimeIndex(df_ipc["fecha"])
df_ipc.drop('fecha',axis=1,inplace=True)
df_ipc.head()

"""Dado que las variaciones del IPC son altas, se tomaran en cuenta solo los valores a partir del 2018-01-01"""

df_ipc = df_ipc[df_ipc.index >= '2018-01-01']
df_ipc

"""Parametros de la RNN"""

SEQ_LEN = 6  # how long of a preceeding sequence to collect for RNN
FUTURE_PERIOD_PREDICT = 5  # how far into the future are we trying to predict?
RATIO_TO_PREDICT = "valor"

"""Se grafican los datos"""

df_ipc.plot(subplots=True, figsize=(9, 3))

"""Se normaliza los resultados"""

# Normalize
scaler = MinMaxScaler()
values = df_ipc[RATIO_TO_PREDICT].to_numpy().reshape(-1, 1)
scaler.fit(values)
df_ipc[RATIO_TO_PREDICT] = scaler.transform(values)
df_ipc.head()

data = np.array(df_ipc[RATIO_TO_PREDICT]).reshape(-1, 1)

def univariate_data(dataset, start_index, end_index, history_size, target_size):
  data = []
  labels = []

  start_index = start_index + history_size
  if end_index is None:
    end_index = len(dataset) - target_size

  for i in range(start_index, end_index):
    indices = range(i-history_size, i)
    # Reshape data from (history_size,) to (history_size, 1)
    data.append(np.reshape(dataset[indices], (history_size, 1)))
    labels.append(dataset[i:i+target_size].reshape(-1))
  return np.array(data), np.array(labels)

TRAIN_SPLIT = math.floor(data.shape[0]*0.50) # 70% for training set

data_x_train, data_y_train = univariate_data(data, 0, TRAIN_SPLIT, SEQ_LEN, FUTURE_PERIOD_PREDICT)
data_x_test, data_y_test = univariate_data(data, TRAIN_SPLIT, None, SEQ_LEN, FUTURE_PERIOD_PREDICT)
data_x_train.shape

data_y_train.shape

data_x_test.shape

data_y_test.shape

"""# Definicion del Modelo"""

# Commented out IPython magic to ensure Python compatibility.
# TensorBoard
import datetime, os
# %load_ext tensorboard

logdir = os.path.join("logs", datetime.datetime.now().strftime("%Y%m%d-%H%M%S"))
tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir)

# %tensorboard --logdir logs

input_layer = tf.keras.Input(shape=data_x_train.shape[-2:], name="input")
lstm_2 = tf.keras.layers.LSTM(256, activation='relu')(input_layer)
out = tf.keras.layers.Dense(FUTURE_PERIOD_PREDICT)(lstm_2)

model = tf.keras.models.Model(inputs=[input_layer], outputs=out)

model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=1.0, learning_rate=0.001), loss='mean_squared_logarithmic_error')

model.summary()

es = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', 
    mode='min', 
    verbose=1, 
    patience=100, 
    restore_best_weights=True)

model.fit(data_x_train, data_y_train,
          epochs=800,
          validation_data=(data_x_test, data_y_test),
          callbacks=[tensorboard_callback, es])

"""# Visualizar Resultados"""

def create_time_steps(length):
  time_steps = []
  for i in range(-length, 0, 1):
    time_steps.append(i)
  return time_steps

def multi_step_plot(history, true_future, prediction):
  plt.figure(figsize=(12, 6))
  num_in = create_time_steps(len(history))
  num_out = len(true_future)

  plt.plot(num_in, np.array(history[:]), label='History')
  plt.plot(np.arange(num_out)/1, np.array(true_future), 'bo',
           label='True Future')
  if prediction.any():
    plt.plot(np.arange(num_out)/1, np.array(prediction), 'ro',
             label='Predicted Future')
  plt.legend(loc='upper left')
  plt.show()

multi_step_plot(data_x_test[0], data_y_test[0], model.predict(data_x_test)[0])

"""## Predicted Data"""

data_test, data_test_y = univariate_data(data, 18, data.shape[0], SEQ_LEN, FUTURE_PERIOD_PREDICT)
data_test.shape, data_test_y.shape

prediction = model.predict(data_test)[0]

plt.plot(prediction)

plt.plot(data)

real_data_prediction = scaler.inverse_transform(prediction.reshape(-1,1))

"""Valores reales de la prediccion"""

real_data_prediction

plt.plot(real_data_prediction)